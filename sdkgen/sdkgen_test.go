package sdkgen

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestGenerate_Pokemon(t *testing.T) {
	tmpDir := t.TempDir()
	configPath := filepath.Join("testdata", "pokemon.sdkgen.yaml")

	gen := New(
		WithConfigPath(configPath),
		WithOutputDir(tmpDir),
	)

	err := gen.Generate()
	require.NoError(t, err)

	// Verify config
	configContent, err := os.ReadFile(filepath.Join(tmpDir, "config", "config.go"))
	require.NoError(t, err)
	assert.Contains(t, string(configContent), "Code generated by openapi sdkgen; DO NOT EDIT.")
	assert.Contains(t, string(configContent), "package config")
	assert.Contains(t, string(configContent), "DefaultConfig")
	assert.Contains(t, string(configContent), "APIUrl")
	assert.Contains(t, string(configContent), `"https://pokeapi.co"`)

	// Verify services
	serviceFiles, _ := filepath.Glob(filepath.Join(tmpDir, "services", "*_service.go"))
	assert.Len(t, serviceFiles, 3, "expected 3 services: pokemon, type, ability")

	// Verify models
	modelFiles, _ := filepath.Glob(filepath.Join(tmpDir, "models", "*.go"))
	assert.NotEmpty(t, modelFiles)

	// Verify no client/error (hand-written)
	_, err = os.Stat(filepath.Join(tmpDir, "client", "client.go"))
	assert.True(t, os.IsNotExist(err))
	_, err = os.Stat(filepath.Join(tmpDir, "client", "error.go"))
	assert.True(t, os.IsNotExist(err))

	// Verify generated SDK root
	sdkRoot, err := os.ReadFile(filepath.Join(tmpDir, "pokemon.go"))
	require.NoError(t, err)
	sdkStr := string(sdkRoot)
	assert.Contains(t, sdkStr, "package pokemon")
	assert.Contains(t, sdkStr, "func NewSDK(")
	assert.Contains(t, sdkStr, "*resty.Client")

	// Verify generated types.go
	typesContent, err := os.ReadFile(filepath.Join(tmpDir, "types.go"))
	require.NoError(t, err)
	typesStr := string(typesContent)
	assert.Contains(t, typesStr, "package pokemon")
	assert.Contains(t, typesStr, "= models.")

	// Verify pokemon service content
	pokemonSvc, err := os.ReadFile(filepath.Join(tmpDir, "services", "pokemon_service.go"))
	require.NoError(t, err)
	svc := string(pokemonSvc)
	assert.Contains(t, svc, "package services")
	assert.Contains(t, svc, "PokemonService")
	assert.Contains(t, svc, "GetPokemon")
	assert.Contains(t, svc, "ListPokemon")
	assert.Contains(t, svc, "*resty.Client")
	assert.Contains(t, svc, `"api/pkg/sdk/pokemon/models"`)
	assert.Contains(t, svc, "result.Raw = raw")
	assert.NotContains(t, svc, `"api/pkg/tracer"`)
	assert.NotContains(t, svc, `"api/pkg/logger"`)
	assert.NotContains(t, svc, `"go.opentelemetry.io/otel"`)

	// Verify ability service
	abilitySvc, err := os.ReadFile(filepath.Join(tmpDir, "services", "ability_service.go"))
	require.NoError(t, err)
	assert.Contains(t, string(abilitySvc), "AbilityService")
	assert.Contains(t, string(abilitySvc), "GetAbility")
	assert.Contains(t, string(abilitySvc), "ListAbilities")

	// Verify models contain Pokemon struct
	pokemonModel, err := os.ReadFile(filepath.Join(tmpDir, "models", "pokemon.go"))
	require.NoError(t, err)
	pm := string(pokemonModel)
	assert.Contains(t, pm, "type Pokemon struct")
	assert.Contains(t, pm, "type PokemonList struct")
	assert.Contains(t, pm, `json:"name"`)
	assert.Contains(t, pm, "Raw")
	assert.Contains(t, pm, "`json:\"-\"`")

	// Verify common models (shared structs not directly tied to one tag)
	commonModel, err := os.ReadFile(filepath.Join(tmpDir, "models", "common.go"))
	require.NoError(t, err)
	assert.Contains(t, string(commonModel), "type NamedResource struct")

	// Verify enum generation
	found := false
	for _, mf := range modelFiles {
		content, _ := os.ReadFile(mf)
		if s := string(content); contains(s, "ElementType") {
			assert.Contains(t, s, `type ElementType string`)
			assert.Contains(t, s, `ElementTypeFire`)
			assert.Contains(t, s, `ElementTypeWater`)
			assert.Contains(t, s, `ElementTypeDragon`)
			found = true
		}
	}
	assert.True(t, found, "expected ElementType enum in some model file")
}

func contains(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(s) > 0 && containsStr(s, substr))
}

func containsStr(s, sub string) bool {
	for i := 0; i <= len(s)-len(sub); i++ {
		if s[i:i+len(sub)] == sub {
			return true
		}
	}
	return false
}

func TestNaming(t *testing.T) {
	tests := []struct {
		input  string
		pascal string
		camel  string
		snake  string
	}{
		{"balance_service", "BalanceService", "balanceService", "balance_service"},
		{"getBalances", "GetBalances", "getBalances", "get_balances"},
		{"HTTPClient", "HTTPClient", "httpClient", "http_client"},
		{"apiKey", "APIKey", "apiKey", "api_key"},
		{"id", "ID", "id", "id"},
		{"user_id", "UserID", "userID", "user_id"},
	}

	for _, tt := range tests {
		t.Run(tt.input, func(t *testing.T) {
			assert.Equal(t, tt.pascal, toPascalCase(tt.input))
			assert.Equal(t, tt.camel, toCamelCase(tt.input))
			assert.Equal(t, tt.snake, toSnakeCase(tt.input))
		})
	}
}

func TestLoadSDKGenConfig(t *testing.T) {
	cfg, err := LoadSDKGenConfig(filepath.Join("testdata", "pokemon.sdkgen.yaml"))
	require.NoError(t, err)

	assert.Equal(t, "pokemon", cfg.Provider.Name)
	assert.Equal(t, "Pokemon", cfg.Provider.DisplayName)
	assert.Equal(t, "pokemon", cfg.Config.Prefix)
	assert.Equal(t, "api/pkg/sdk/pokemon", cfg.Output.ModulePath)
	assert.Len(t, cfg.Config.Fields, 3)
}
