// Code generated by openapi sdkgen; DO NOT EDIT.

package services

import (
	"context"
	"encoding/json"
	"fmt"
	"strconv"

	"github.com/tidwall/gjson"
	"go.uber.org/zap"
	"resty.dev/v3"

	"{{.ModulePath}}/models"
)
{{range .Service.Methods}}
{{- if .UseParamsStruct}}

// {{.ParamsStructName}} holds the parameters for the {{.Name}} operation.
type {{.ParamsStructName}} struct {
{{- range .PathParams}}
	{{.GoName | pascal}} {{.GoType}}
{{- end}}
{{- range .QueryParams}}
	{{.GoName | pascal}} {{.GoType}}
{{- end}}
}
{{- end}}
{{- end}}

// {{.Service.Name}}Service provides access to {{.Service.Name}} API operations.
type {{.Service.Name}}Service struct {
	client *resty.Client
	logger *zap.Logger
}

// New{{.Service.Name}}Service creates a new {{.Service.Name}}Service instance.
func New{{.Service.Name}}Service(client *resty.Client, logger *zap.Logger) *{{.Service.Name}}Service {
	return &{{.Service.Name}}Service{
		client: client,
		logger: logger,
	}
}
{{range .Service.Methods}}

{{- if .Comment}}
{{.Comment | comment (.Name | printf "%s ")}}
{{- else}}
// {{.Name}} executes the {{.HTTPMethod}} {{.Path}} operation.
{{- end}}
{{- if .UseParamsStruct}}
func (s *{{$.Service.Name}}Service) {{.Name}}(ctx context.Context, params {{.ParamsStructName}}{{if .HasRequestBody}}, req {{.RequestBodyType}}{{end}}) ({{if .ResponseType}}{{.ResponseType}}, {{end}}error) {
{{- else}}
func (s *{{$.Service.Name}}Service) {{.Name}}(ctx context.Context{{range .PathParams}}, {{.GoName}} {{.GoType}}{{end}}{{range .QueryParams}}, {{.GoName}} {{.GoType}}{{end}}{{if .HasRequestBody}}, req {{.RequestBodyType}}{{end}}) ({{if .ResponseType}}{{.ResponseType}}, {{end}}error) {
{{- end}}
	r := s.client.R().SetContext(ctx)
{{- if .UseParamsStruct}}
{{- range .PathParams}}
	r.SetPathParam("{{.Name}}", {{. | formatParamStruct}})
{{- end}}
{{- range .QueryParams}}
{{- if .Required}}
	r.SetQueryParam("{{.Name}}", {{. | formatParamStruct}})
{{- else}}
	if params.{{.GoName | pascal}} != {{.GoType | zeroValue}} {
		r.SetQueryParam("{{.Name}}", {{. | formatParamStruct}})
	}
{{- end}}
{{- end}}
{{- else}}
{{- range .PathParams}}
	r.SetPathParam("{{.Name}}", {{. | formatParam}})
{{- end}}
{{- range .QueryParams}}
{{- if .Required}}
	r.SetQueryParam("{{.Name}}", {{. | formatParam}})
{{- else}}
	if {{.GoName}} != {{.GoType | zeroValue}} {
		r.SetQueryParam("{{.Name}}", {{. | formatParam}})
	}
{{- end}}
{{- end}}
{{- end}}
{{- if .HasRequestBody}}
	r.SetBody(req)
{{- end}}

	resp, err := r.{{.HTTPMethod | methodFunc}}("{{.Path}}")

	var data gjson.Result
	if resp != nil {
		data = gjson.ParseBytes(resp.Bytes())
	}
	if err != nil {
		s.logger.Error("error while calling {{.Name}}",
			zap.Error(err),
			zap.Any("response", data.Value()),
{{- if .UseParamsStruct}}
{{- range .PathParams}}
			{{. | zapFieldStruct}},
{{- end}}
{{- range .QueryParams}}
			zap.Any("{{.Name}}", params.{{.GoName | pascal}}),
{{- end}}
{{- else}}
{{- range .PathParams}}
			{{. | zapField}},
{{- end}}
{{- range .QueryParams}}
			zap.Any("{{.Name}}", {{.GoName}}),
{{- end}}
{{- end}}
		)
		return {{if .ResponseType}}{{.ResponseType | zeroValue}}, {{end}}err
	}
{{- if .ResponseType}}
	{{- if .ResponseWrapper}}

	raw := data.Get("{{.ResponseWrapper}}").Raw
	{{- else}}

	raw := data.Raw
	{{- end}}

	var result {{.ResponseType | baseType}}
	if err := json.Unmarshal([]byte(raw), &result); err != nil {
		s.logger.Error("error while unmarshalling {{.Name}} response",
			zap.Error(err),
			zap.Any("response", data.Value()),
		)
		return {{.ResponseType | zeroValue}}, err
	}

	{{- if isSlice .ResponseType}}
	{{- if not (isPrimitiveSlice .ResponseType)}}
	{{- if .ResponseWrapper}}
	items := data.Get("{{.ResponseWrapper}}").Array()
	{{- else}}
	items := data.Array()
	{{- end}}
	for i := range result {
		if i < len(items) {
			result[i].Raw = items[i].Raw
		}
	}
	{{- end}}
	{{- else}}
	result.Raw = raw
	{{- end}}
	return result, nil
{{- else}}

	return nil
{{- end}}
}
{{- end}}
